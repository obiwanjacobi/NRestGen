# NRestGen

> Generate .NET REST Service code for ASP.NET Core (MVC).

Generate server and client side code based on conventions for implementing/calling a REST service.

RAML and OpenAPI both provide a 'markup language' for specifying REST APIs.
RestGen takes it further and generates much of the plumbing needed.
This should make it quick and easy to use and get a server skeleton to implement.
Round-trip development (iterations) must be possible. Also regenerate with a new version (side-by-side with older version)

TBD:

- Versioning (separate version in separate assembly for handlers, validators)
- Security
- Caching
- Validation
- Aggregates (auto-expand) Or is that a function of the Handler?
- Search (at resource collection level - based on -any- field values)
- Service Operations (outside resource model) Allow on instance?=>NO
- ETAG / optimistic locking
- Generate Unit Tests
- Generate DocComments on Controllers to include in Swagger.
- Generate `[Produces]` attributes on Controllers.
- GraphQL?
- CQRS?
- Batch: https://devblogs.microsoft.com/odata/all-in-one-with-odata-batch/?WT.mc_id=ondotnet-c9-cephilli

- Look into 'Link Header' RFC 5988 (data paging)
- CancellationToken during Request processing.
- OData
https://github.com/OData/AspNetCoreOData/blob/master/sample/ODataRoutingSample/Startup.cs

ISSUES:
- OData does not seem to like versioned paths!?
    Exception thrown: 'Microsoft.OData.UriParser.ODataUnrecognizedPathException' in Microsoft.AspNetCore.OData.dll
    Exception thrown: 'System.NullReferenceException' in Microsoft.AspNetCore.Mvc.Versioning.dll
    Object reference not set to an instance of an object.
    https://channel9.msdn.com/Shows/On-NET/Adding-a-little-Swagger-to-OData
https://github.com/microsoft/aspnet-api-versioning/tree/master/samples/aspnetcore/SwaggerODataSample

## Conventions

https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design
https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md
https://mathieu.fenniak.net/the-api-checklist/

- uris by convention / best practice
- EdmModel conventions https://docs.microsoft.com/en-us/odata/webapi/convention-model-builder

## Resource Model

REST puts the resource model central and this is what we use to generate the server (and client).

Resource Entities (types) are defined and related to each other in the model.

- Specify what Entity Properties are used for what verbs (and generate specific classes for each?)

> Use IEdmModel.

Adding navigation properties to the model to define resource entity relations,
will also expose these to the public contract. That is not what we want (in all cases).

## URIs

The generated URIs all follow the following convention:

- Each type is represented by a collection (unless explicitly marked?).

- Each collection can be indexed by the type's Id (predefined name, or use `[key]` attribute?).

- Each index resource collection can be extended one more level to access related data.

```URI
//collection/{id}/sub
//customers/12345/orders
```

- The sub-collection is also accessible through the root.

- The handling code (implementation) receives an extra context-object that communicates if it's being called from the root or in the context of another resource instance.

- The context-object also contains extra information on any filters that need to be applied to the retrieval of the resources (odata: filter, orderBy, data-paging, count, select).

- All query-string parameters are available on the context-object.

- GET, PUT, POST, DELETE, PATCH, HEAD, OPTIONS are supported/generated for each root resource type.
    - POST is an asynchronous create. Location header.
    - PUT is a synchronous upsert. Location header.
    - PATCH is a merge.
    - HEAD for large binary responses (images/documents) - will not be included in standard response if on resource type. Support Accept-Range header for partial gets (206)?
    - OPTIONS for link table

- Status URI for accessing the progress of async calls.
    - IAsyncOperationStatus interface to be implemented - imported by StatusController.

- Extra specific endpoint must be possible for explicit cases. Implement by hand.

- Error can be generated by the implementation using the provided Exceptions. All errors will be translated to the correct HTTP Status code and carry the std error body.

## Navigation (HATEOAS)

The generated code will automatically support generating navigation links base on the resource model.
For each resource (instance) a handler will have to decide what actions/links will be available. Perhaps return valid verbs?

Each link will have:

- rel : [resource type name] or `self`.
- href : the relative url to the resource.
- action : verbs (GET, POST, PUT, DELETE etc)
- types: supported media-types for the body (optional).

Based on the relations defined in the resource model, GET-links are provided for each related resource type. For `self` also DELETE and PUT are available.
One-to-many and one-to-one links should be included (navigation properties in model).

> Include these links in the body of the OPTIONS (verb) result?

> May need to be able to include this in the response body or have another URI to access it - some admins disable the OPTIONS verb.

> Generate links to expanded/related data not in the current result set?: Return a link to Orders of a requested Customer.

See also: https://tools.ietf.org/html/draft-kelly-json-hal-08

## Filters

Filters are similar to odata (on query string) available in the context-object.

- Filtering the result set rows (filter)
- Filtering the resulting instance fields (select)
- Data-paging (offset/limit)
- ordering based on fields of the type.

The response is wrapped in a container object.

- Result: the requested resources
- DataPaging current page/size (incl. links to next/prev pages)
- Links (HATEOAS)
- Error: standard error message format.

## Service Operations

```URL
/customers/list-operation
/customers/123/entity-operation
```

## Code Generation

Generates model/type classes and Controllers.
Use T4 tech and a custom object model.
Options for media-type and security are per Controller (resource type).

Allow for and indirection that allows mapping from resource types to internal data types.
Allow to not generate for Mediatr.
Generate a StartUp helper/extension that has the correct config calls for setup.
    IServiceCollection.AddNRestGen() and IEndpointRouterBuilder.AddOData()

### Mediatr

implement using Mediatr? https://github.com/jbogard/MediatR/wiki

Could be useful to separate the Controller plumbing and actual impl. Also provides interception points for adding logging, transactions and more.

### Fluent Validation

Any good?

## Configuration Options

- Namespace
- Navigation Depth (Controllers: uri paths)
- Resources (not) available from root / Aggregates?
- ResourceModel: Binary Properties that have to queried separately (partial responses?).
- Target locations (Projects/Folders) -and naming- for Resource Model, Controller and Request classes
- Use Mediatr (on/off)
- Enable OData (EnableQuery, ParseQueryString or Off)
- Link table as response of OPTIONS
- version strategy (url/header/media-type)
- error reporting strategy
- Security settings
- validation strategy (Fluent Validation?)
- ResourceModel <=> Internal/domain mapping
- Swagger: https://channel9.msdn.com/Shows/On-NET/Adding-a-little-Swagger-to-OData?WT.mc_id=channel9-twitter-cda

## Similar Tools

https://github.com/mulesoft-labs/raml-dotnet-tools/wiki
https://github.com/RicoSuter/NSwag

## Credits

T4 Multiple File Manager
https://github.com/damieng/DamienGKit
https://damieng.com/blog/2009/11/06/multiple-outputs-from-t4-made-easy-revisited
